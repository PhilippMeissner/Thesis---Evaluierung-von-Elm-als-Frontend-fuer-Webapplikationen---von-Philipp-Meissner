\chapter{Fazit}
\label{chap:fazit}
Ziel dieser wissenschaftlichen Arbeit war es, die Programmiersprache Elm auf unterschiedlichste Gesichtspunkte hin zu evaluieren und speziell für die Verwendung im Bereich der Webentwicklung zu prüfen. Infolgedessen wurde eine \ac{SPA} überführt in eine native Elm-Applikation. In der herkömmlichen Webentwicklung ist es üblich die darstellbare Oberfläche einer Webseite mit \ac{HTML}, das Styling mit \ac{CSS} und Interaktionen mit \ac{JS} zu programmieren. Ein Entwickler hat dadurch zwangsweise drei Programmiersprachen zu bedienen. Einerseits mündet dieses Konzept in einer klaren Trennung der Applikation, andererseits muss jede Programmiersprache dem Entwickler bekannt sein. Ferner werden \ac{JS}-Skripte genutzt, um die dargestellte Webseite weiter zu verändern, Interaktionen des Nutzers abzufangen und darauf zu reagieren, wodurch die Webseite unter Umständen undefinierte Zustände erreicht und ausgeführte Skripte im Konflikt miteinander stehen.
Elm hingegen bringt die funktionale Programmierung mit einem expliziten Typensystem, reinen Funktionen und klar strukturierten Style-Guides in die Webentwicklung. Das hinter Elm stehende Konzept beruht darauf, zuverlässige Applikationen zu entwickeln. Der initiale Aufwand bei der Entwicklung einer Elm-Applikation ist dabei höher als bei der üblichen Entwicklung von Webseiten, der Aufwand die Applikation zu erweitern, Codeteile auszulagern und ungenutzte Teile zu entfernen ist hingegen wesentlich unkomplizierter.
Zu Beginn der praktischen Ausarbeitung war unklar, inwiefern die native Implementierung der \ac{SPA} in Elm mit den bestehenden \ac{JS}-Skripten und \ac{CSS}-Definitionen funktionieren wird und ob etwaige Änderungen notwendig sind. Bestenfalls wären sämtliche Garantien die Elm liefert, mit der Überführung des des \ac{HTML}-Codes in der Applikation eingebunden, ohne die \ac{JS}- und \ac{CSS}-Dateien verändern zu müssen.
Die Überführung der Elm-Applikation ergab, dass lediglich zwei der insgesamt neun geprüften Kriterien nur teilweise erfüllt wurden. Die verbleibenden Kriterien wurden vollständig erfüllt. Zu den unerfüllten Kriterien gehörte unter anderem die Interoperabilität, mit der geklärt werden sollte, inwiefern die Funktionalität vorhandener \ac{JS}-Skripte gegeben sei, wenn der Rest der Applikation nativ in Elm verwirklicht wird. Ergebnis der Auswertung war, dass nicht alle \ac{JS}-Skripte einwandfrei mit dem nativ in Elm programmierten Teil der Applikation, genauer der \ac{DOM}, kommunizierten. Die Ereignisbehandler, die durch die bestehenden \ac{JS}-Skripte erzeugt wurden, bezogen sich dabei auf Elemente die sich zur Zeit ihrer Initialisierung noch nicht im Zugriffsbereich des Skriptes befanden, da die Elm-Applikation erst nachträglich in die \ac{DOM} injiziert wurde. Zusätzlich nutzt Elm das Konzept der $virtual-dom$, wodurch die tatsächliche Repräsentation des \ac{DOM} nicht direkt von außen zugreifbar ist und sich unter Umständen verändert, wodurch die vorherigen Ereignisbehandler nicht mehr auf die ursprünglichen Elemente in der \ac{DOM} zugreifen. Die Dateigröße einer Elm-Applikation mit den Grundfunktionen zur Darstellung eines \ac{HTML}-Elementes im Browser war zufriedenstellend gering. Jedoch wird die erzeugte Datei nicht minimiert, obwohl dies mit einfachsten Mitteln bewerkstelligt werden kann. Der Test ergab, dass die Datei um mehr als 60\% kleiner sein könnte, wenn eine standardmäßige Verkleinerung der Datei durch den $elm-compiler$ stattfinden würde.

Der selbst erzeugte Quellcode wies eine sehr hohe Wartbarkeit und Lesbarkeit auf, zum einen wegen der Vielzahl an unterstützenden Plugins die es für die Entwicklungsumgebungen gibt, zum anderen aufgrund der Hilfe durch den $elm-compiler$. Hier wird dem Entwickler viel Arbeit erspart und gleichzeitig Sicherheit über die Zuverlässigkeit der Applikation vermittelt. Die Fehlermeldungen waren sehr detailliert und überwiegend akkurat, wodurch davon ausgegangen werden kann, dass eine kompilierte Elm-Applikation keine Laufzeitfehler erzeugt. Zuverlässig ist der erzeugte Quellcode auch hinsichtlich der Nutzung auf unterschiedlichen Plattformen. Es gab keinerlei Fehler bei der Kompilierung des Codes unter den gängigsten Betriebssystemen. Trotz der Plattformunabhängigkeit überzeugte die Elm-Applikation mit hoher Effizienz. Die getestete Applikation erwies sich als deutlich schneller als andere beliebte Frameworks wie AngularJS oder React. Obwohl sich die Benchmarks auf ältere Versionen der getesteten Frameworks stützen, ist davon auszugehen, dass die Ergebnisse der aktuellsten Versionen ähnlich ausfallen. Um exakte Ergebnisse zu ermitteln, müsste die Applikation $TodoMVC\,Performance\,Comparison$ in allen Programmiersprachen auf die neueste Version aktualisiert werden.
Im Rahmen dieser Arbeit hat sich ebenfalls ergeben, dass Code mit einfachsten Mitteln modularisiert werden konnte. Dadurch entstand eine hohe Übersichtlichkeit innerhalb des Quellcodes. Module konnten ferner beliebig oft an anderen Stellen eingebunden und genutzt werden.
Die Elm-Applikation kompilierte nicht nur auf allen getesteten Plattformen fehlerfrei, sondern bot auch eine erstaunliche Browser-Kompatibilität. Die Darstellung in den getesteten Browsern war stets fehlerfrei und erzeugte fast gänzlich gleiche Ergebnisse. Marginale Unterschiede sind auf die verschiedenen Browser selbst zurückzuführen, die einige \ac{HTML}-Elemente unterschiedlich darstellen. Ein Entwickler kann darauf nur mit entsprechendem \ac{CSS}-Styling Einfluss nehmen.
Trotz der unveränderbaren Datenstrukturen in Elm war es möglich Daten asynchron zu verarbeiten. Mit Hilfe eines $Tasks$ konnte ein asynchroner Request an einen externen Server gesendet, die Antwort ausgewertet und auf dem Bildschirm dargestellt werden, ohne den Zustand der Applikation zu gefährden und einen Absturz zu erzeugen.

Zusammenfassend lässt sich sagen, dass Elm die Anforderungen der Webentwicklung fast vollständig erfüllt. Lediglich die Interoperabilität bedarf der Umsetzung eines anderen Konzeptes.
Sämtliche Tests dieser wissenschaftlichen Arbeit beziehen sich bewusst auf grundlegende Aspekte der Programmiersprache, um so allgemeine Erkenntnisse daraus ziehen zu können. Die \ac{SPA} ist denkbar einfach aufgebaut, zeigt jedoch alle Konzepte die Elm nutzt und für wichtig erklärt. Während der Entwicklung wurde deutlich, dass das $Model$ den Status der Applikation innehält. Dadurch lag der Fokus während der Entwicklung eher auf den zu verarbeitenden Daten, als auf der letztlichen Darstellung. Die Programmiersprache Elm bietet sich folglich eher für Web-Applikationen an, die deutlich mehr Logik als eine \ac{SPA} beinhalten, oder mehr Interaktionen mit dem Nutzer anstreben. Gerade aufgrund der ausgeprägten Unterstützung durch den $elm-compiler$ ist Elm auch für Entwickler ohne, oder mit nur geringen Vorkenntnissen im Bereich der funktionalen Programmierung sinnvoll.
