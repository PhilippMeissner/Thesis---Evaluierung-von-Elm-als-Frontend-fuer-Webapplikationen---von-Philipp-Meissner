\chapter{Fazit}
\label{chap:fazit}
Ziel dieser wissenschaftlichen Arbeit war es, die Programmiersprache Elm auf unterschiedlichste Gesichtspunkte hin zu evaluieren und speziell für die Verwendung im Bereich der Webentwicklung zu prüfen. Infolgedessen wurde eine \ac{SPA} überführt in eine native Elm-Applikation. In der herkömmlichen Webentwicklung ist es üblich die darstellbare Oberfläche einer Webseite mit \ac{HTML}, das Styling mit \ac{CSS} und Interaktionen mit \ac{JS} zu programmieren. Ein Entwickler hat dadurch zwangsweise drei Programmiersprachen zu bedienen. Einerseits mündet dieses Konzept in einer klaren Trennung der Applikation, andererseits muss jede Programmiersprache dem Entwickler bekannt sein. Ferner werden \ac{JS}-Skripte genutzt, um die dargestellte Webseite weiter zu verändern, Interaktionen des Nutzers abzufangen und darauf zu reagieren, wodurch die Webseite unter Umständen undefinierte Zustände erreicht und ausgeführte Skripte im Konflikt miteinander stehen.
Elm hingegen bringt die funktionale Programmierung mit einem expliziten Typensystem, unveränderbaren Variablen und puren Funktionen, sowie klar strukturierten Style-Guides und den Ansprüchen eines Entwicklers im Hinterkopf in die Webentwicklung. Das hinter Elm stehende Konzept beruht darauf, zuverlässige Applikationen zu entwickeln. Der initiale Aufwand bei der Entwicklung einer Elm-Applikation ist dabei höher als bei der üblichen Entwicklung von Webseiten, der Aufwand die Applikation zu erweitern, Codeteile auszulagern und ungenutzte Teile zu entfernen ist hingegen wesentlich unkomplizierter.
Zu Beginn der praktischen Ausarbeitung war unklar, inwiefern die native Implementierung der \ac{SPA} in Elm mit den bestehenden \ac{JS}-Skripten und \ac{CSS}-Definitionen funktionieren wird und ob etwaige Änderungen notwendig sind. Bestenfalls wären sämtliche Garantien die Elm liefert, mit der Überführung des Views in der Applikation eingebunden, ohne die \ac{JS}- und \ac{CSS}-Dateien verändern zu müssen.
Die Überführung der Elm-Applikation ergab, dass lediglich zwei der insgesamt neun geprüften Kriterien nur teilweise erfüllt wurde. Die verbleibenden Kriterien wurden vollständig erfüllt. Zu den unerfüllten Kriterien gehörte unter anderem die Interoperabilität, mit der geklärt werden sollte, inwiefern die Funktionalität vorhandener \ac{JS}-Skripte gegeben sei, wenn der Rest der Applikation nativ in Elm verwirklicht wird. Ergebnis der Auswertung war, dass nicht alle \ac{JS}-Skripte einwandfrei mit dem nativ in Elm programmierten Teil der Applikation, genauer der \ac{DOM}, kommunizierten. Die Ereignisbehandler, die durch die bestehenden \ac{JS}-Skripte erzeugt wurden, bezogen sich dabei auf Elemente die zur Zeit ihrer Initialisierung noch nicht im Zugriffsbereich des Skriptes befanden, da die Elm-Applikation erst nachträglich in die \ac{DOM} injiziert wurde. Zusätzlich nutzt Elm das Konzept der $virtual-dom$, wodurch die tatsächliche Repräsentation des \ac{DOM} nicht direkt von außen zugreifbar ist und sich unter Umständen verändert, wodurch die vorherigen Ereignisbehandler nicht mehr auf die ursprünglichen Elemente in der \ac{DOM} zugreifen. Die Dateigröße einer Elm-Applikation mit den Grundfunktionen zur Darstellung eines \ac{HTML}-Elementes im Browser war zufriedenstellend gering. Jedoch wird die erzeugte Datei nicht minimiert, obwohl dies mit einfachsten Mitteln bewerkstelligt werden kann. Der Test ergab, dass die Datei um mehr als 60\% kleiner sein könnte, wenn eine standardmäßige Verkleinerung der Datei durch den $elm-compiler$ stattfinden würde.

Der selbst erzeugte Quellcode wies eine sehr hohe Wartbarkeit und Lesbarkeit auf, zum einen wegen der Vielzahl an unterstützenden Plugins die es für die Entwicklungsumgebungen gibt, zum anderen aufgrund der Hilfe durch den $elm-compiler$. Hier wird dem Entwickler viel Arbeit erspart und gleichzeitig Sicherheit über die Richtigkeit der Applikation geliefert. Die Fehlermeldungen waren sehr detailliert und überwiegend akkurat, wodurch eine Elm-Applikation, sollte sie fehlerfrei kompiliert werden können, als zuverlässig angesehen werden kann. Zuverlässig ist der erzeugte Quellcode auch hinsichtlich der Nutzung auf unterschiedlichen Platformen. Es gab keinerlei Fehler bei der Kompilierung des Codes unter den gängigsten Betriebssystemen. Trotz der Plattformunabhängigkeit überzeugte die Elm-Applikation mit hoher Effizienz. Die getestete Applikation erwies sich als deutlich schneller als andere beliebte Frameworks wie AngularJS oder React. Obwohl sich die Benchmarks auf ältere Versionen der getesteten Frameworks stützen, ist davon auszugehen, dass die Ergebnisse der aktuellsten Versionen ähnlich ausfallen würden. Um exakte Ergebnisse zu ermitteln, müsste die Applikation $TodoMVC\,Performance\,Comparison$ in allen Programmiersprachen auf die neueste Version aktualisiert werden.
Ferner war es denkbar einfach vorhandenen Code in eigene Funktionen und Module auszulagern, um eine bessere Übersichtlichkeit innerhalb des Quellcodes zu erreichen. Dabei können Module beliebig oft an anderen Stellen eingebunden und genutzt werden.
Die Elm-Applikation kompilierte nicht nur auf allen getesteten Plattformen, sondern bot auch eine erstaunliche Kompatibilität mit einer Vielzahl von Browsern. Die Darstellung in den getesteten Browsern war stets fehlerfrei und erzeugte fast gänzlich gleiche Ergebnisse, die nur marginale Unterschiede aufwiesen.
Trotz der unveränderbaren Datenstrukturen in Elm war es möglich Daten asynchron zu verarbeiten. Mit Hilfe eines $Tasks$ konnte ein asynchroner Request an einen externen Server gesendet, die Antwort ausgewertet und auf dem Bildschirm dargestellt werden, ohne den Zustand der Applikation zu gefährden und einen Absturz zu erzeugen.

Zusammenfassend lässt sich sagen, dass Elm die Anforderungen der Webentwicklung fast vollständig erfüllt. Lediglich die Interoperabilität bedarf der Umsetzung eines anderen Konzeptes.
Sämtliche Tests dieser wissenschaftlichen Arbeit beziehen sich bewusst auf grundlegende Aspekte der Programmiersprache, um so allgemeine Erkenntnisse daraus ziehen zu können. Die \ac{SPA} ist denkbar einfach aufgebaut, zeigt jedoch alle Konzepte die Elm nutzt und für wichtig erklärt. Während der Entwicklung der Elm-Applikation wurde deutlich, dass das $Model$ den Status der Applikation innehält. Dadurch schien es, als ob der Fokus während der Entwicklung eher auf den zu verarbeitenden Daten, als auf der letztlichen Darstellung lag. Die Programmiersprache Elm bietet sich folglich eher für Web-Applikationen an, die deutlich mehr Logik als eine \ac{SPA} beinhalten, oder mehr Interaktionen mit dem Nutzer anstreben.

%\begin{enumerate}
%	\item{Gegenüberstellung}
%		\subitem{-} Was war das Ziel und der Wissensstand zu Beginn
%		\subitem{-} Was waren die Erwartungen
%		\subitem{-} Gab es unvorhergesehene Probleme? Wenn ja, welche?
%		\subitem{-} Entsprach das Endergebnis (und der Weg dorthin) dem vorherigen Ziel?
%	\item Aufzählung der maßgeblich wichtigen Punkte
%	\item Résumé
%		\subitem{-} Wie verallgemeinerbar sind die gesammelten Daten?
%		\subitem{-} Erfüllt Elm die Anforderungen der Webentwicklung?
%		\subitem{-} Einstufung, für welche Anwender Elm geeignet ist
%		\subitem{-} Aktuell (noch) bestehende Probleme, die es zu lösen gilt
%\end{enumerate}


