

% 1.1. Elm hat leicht erlernbare Grundkonzepte, die adaptiert und erweiterbar sind, um Produktivität für die Entwickler zu gewährleisten.
% 
% 2.1. Elm Code kann mindestens kommentiert werden, wenn nicht sogar eine Funktion zur automatischen Generierung von Signaturen einer Funktion existiert
% --> Kommentare können mit `--` (single-line) oder `{- a comment - }` erstellt werden. Eine vollautomatische, explizite Erstellung der Signaturen besteht derzeit nicht. Der Compiler wird jedoch nach dem Kompiliervorgang einen Signaturvorschlag geben. Dieser Vorschlag ist auf einer niedrigeren Ebene, als es eine Deklaration wäre, ist jedoch ausreichend und wesentlich sinnvoller als eine Signatur komplett unberücksichtigt zu lassen. Beispiel: Abbildung XY ($compiler_sig_suggestion$ + $compiler_own_sig$)
% ```
% type alias Model = { counter: Int }
% increaseModel: Model -> Model
% increaseModel model =
%     {model | counter = model.counter + 1}
% 
% vs. Kompiliervorschlag
% type alias Model = { counter: Int }
% increaseModel: { a | counter : number } -> { a | counter : number }
% increaseModel model =
%     {model | counter = model.counter + 1}
% ```
% 
% 3.1. Die Erweiterungen des Editors oder der Compiler warnt spätestens bei der Kompilierung, wenn nicht bereits während der Entwicklung vor syntaktischen Fehlern
% --> Syntaktische Fehler werden vom Compiler erkannt und ein Fehler angezeigt. Der Fehler wird unterstützt durch einen Hinweis auf die mögliche Fehlerquelle (Abbildung XY ? $Compiler_syntax_error$). Die Fehlermeldung wird erst nach der Kompilierung eingeblendet.
% ```
% div [ id "elm-view" ]
%         [ Navigation.view model
%             Header.view
%         , Services.view]
% ```
% 
% 3.2. Gibt es keine Fehlermeldungen, wird die Applikation ohne Laufzeitfehler funktionieren
% --> Aufgrund der Garantien, dass es keine Seiteneffekte gibt und alle Variablen unveränderlich sind, ist die Korrektheit syntaktische und semantische Korrektheit des Codes gewährleistet. Lediglich die logische Implementierung eines Algorithmus kann noch Fehler aufweisen, dies kann jedoch nicht von einem Compiler überprüft werden.
% 3.3. Fehlermeldungen werden sehr spezifisch auf das eigentliche Problem hinweisen
% --> Wie in Abbildung iii.i zu sehen ist, gibt der Compiler nicht nur an, in welcher Zeile ein Fehler gefunden wurde, sondern liefert zusätzlich noch einen Hinweis, worin eine wahrscheinliche Fehlerquelle liegt. In diesem Beispiel weißt der Compiler auf das fehlende Komma als Fehlerquelle hin.
% 
% 4.1  1. Die SPA wird auf allen gängigen Browsern fehlerfrei dargestellt
% --> AUSSTEHEND
% 
% 5.1. Der Kompiliervorgang wird nur wenige Sekunden dauern, jedoch mehr Zeit in Anspruch nehmen, als die herkömmliche Entwicklung mit reinem\ac{HTML},\ac{CSS} und\ac{JS}
% --> Bei der herkömmlichen Entwicklung ist kein expliziter Kompiliervorgang notwendig, stattdessen übernimmt der Browser die Darstellung des übergebenen\ac{HTML},\ac{CSS} und\ac{JS} Quellcodes. Der Kompiliervorgang der Elm-Applikation dauert wie in Abbildung XY  zu sehen ist im Durchschnitt XY Sekunden. Es wurde 10x gemessen, der höchste und niedrigste Wert gestrichen und dann das arithmetische Mittel der verbleibenden 8 Messungen ermittelt.
% 
% 5.2  2. Die erzeugte Elm-Applikation ist deutlich schneller während der Laufzeit
% --> AUSSTEHEND (Abbildung - Performance - Evtl. neu?)
% 
% 6. 1. Codeteilen lassen sich problemlos auslagern und wiederverwenden
% --> Der komplette View wurde von einer großen Darstellung in mehrere Funktionen unterteilt und letztlich in ein eigenes Modul überführt. Analog dazu wurden auch das Model, sowie die Update-Funktion ausgelagert. Das einmalig definierte `Model` kann in sämtlichen Modulen wiederverwendet werden, auch die einzelnen Funktionen eines jeden Moduls finden erneut Verwendung, insofern gewünscht.
% 
% 7.1. Ausgelagerte Codeteile sind isoliert voneinander und als einzelnes Modul nutzbar
% --> Diese Eigenschaft ist gegeben.
% 7.2. Module können Funktionen nach außen verbergen
% --> Jedes Modul kann mit dem Stichwort `expose` einzelne Funktionen nach außen hin zugänglich machen. Das importierende Modul wiederum kann einzelne Funktionen in den derzeitigen globalen `Scope` laden.
% 
% 8.1. Die automatische Formatierung des Elm-Codes macht diesen lesbarer und spart Zeit
% --> Fehler werden Dank der Formatierung schnell sichtbar.
% 
% 9.1. Die Dateigröße der Elm-Applikation wird kleiner als bei vergleichbaren Frameworks ausfallen
% --> Die kompilierte Elm-Applikation hat eine Größe von etwa 300kb. Allerdings kann diese Größe um etwa 60Prozent verringert werden, wenn der Code `minified` wird.
%
%10.1. Bestehende\ac{JS}-Skripte können mit der Elm-Applikation interagieren oder funktionieren bereits einwandfrei
%--> Die Integration vorhandener\ac{JS}-Skripte verlief problemlos. Benötigt ein externes Skript Daten von der Elm-Applikation, so kann mit Hilfe von `Ports` eine gesicherte Kommunikation in beide Richtungen stattfinden.
%
%10.2. Bestehender\ac{CSS}-Code kann nativ in Elm eingebunden werden
%--> Das Einbinden von\ac{CSS} Quellen ist derzeit nicht ohne Probleme nativ in Elm möglich. Es verursacht ein ?flackern? und ist nicht für den Gebrauch in einem fertigen System geeignet.\ac{CSS}-Klassen und `inline-styling` sind jedoch nativ in Elm implementiert und erlauben ein Styling der Elemente. Externes\ac{CSS} muss jedoch über das Grundgerüst der\ac{HTML}-Datei eingebunden werden.
%
%11.1. Elm erlaubt asynchrone Requests ohne Seiteneffekte zu erzeugen
%--> Ein asynchroner Request stellt implizit einen Seiteneffekt dar, wird in Elm allerdings als gemanagter Seiteneffekt bezeichnet. In jedem Fall ist der Nutzer gezwungen eine Funktion bei einer fehlerhaften Übertragung zu übergeben, die dann die erwartenden Typen/Werte liefert.



%\begin{enumerate}[label*=\arabic*.]
%
%\item Externes \ac{CSS} kann nicht nativ über Elm geladen werden
%	\begin{enumerate}[label*=\arabic*.]
%		\item Inline-\ac{CSS} muss manuell mehrfach abgeändert werden
%		\item Keine Schachtelung möglich
%		\item Browser kann inline-\ac{CSS} nicht zwischenspeichern
%	\end{enumerate}
%\item Ein \ac{HTML}-Element benötigt in Elm weniger Zeichen
%	\begin{enumerate}[label*=\arabic*.]
%		\item \ac{HTML}-Code benötigt in Elm keine schließenden Klammern. Anders als \ac{HTML} arbeitet Elm mit Einrückungen. Die gleichnamigen Funktionen um ein \ac{HTML}-Element zu erzeugen benötigen dementsprechend lediglich den Funktionsaufruf, gefolgt von den zwei Argumenten. Das bedeutet, dass nativer Code in Elm kürzer und weniger anfällig für Flüchtigkeitsfehler wie beispielsweise das Schließen eines Tags ist. Der Entwickler wird weniger syntaktische Fehler machen.
%	\end{enumerate}
%\item Vertikale und horizontale Zentrierung eines Elementes ist umfangreicher als vorerst erwartet
%	\begin{enumerate}[label*=\arabic*.]
%		\item Obwohl Elm ein Paket für genau dieses Anwendungsgebiet besitzt, ist die Anwendung dennoch weder simpel, noch voll funktionsfähig. Es bedarf einiger Transformationen der Elemente, um sie in nutzbare, validen \ac{HTML}-Code zu formatieren. Zuletzt trifft der Entwickler auf die Problematik, zusätzlich noch die explizite Größe des Fensters mit einbeziehen zu wollen, so dass das Element den gesamten Bildschirm ausfüllt und einen zentrierten Text beinhaltet. Die Fenstergröße zu ermitteln stellt ein größeres Hindernis dar, als zunächst erwartet. Die Möglichkeiten sind hier, halbwegs dynamisch die Fenstergröße bei der Initiierung der Elm-Applikation an diese weiter zureichen, oder über Ports abzufangen, wenn sich die Fenstergröße geändert hat. Die erste Lösung hilft nur, wenn die Größe des Fensters nicht weiter verändert wird. Dies kann jedoch nicht gewährleistet werden, wodurch die Lösung entfällt. Die zweite Lösung hingegen erzeugt eine zusätzliche Abhängigkeit zwischen Elm und externem \ac{JS}. Zuletzt bleibt noch die altbekannte Möglichkeit mittels \ac{CSS} den Text in einem Element beidseitig zu zentrieren. Hierfür kann das externe \ac{CSS}-Framework Flexbox zuhilfe gezogen werden. Flexbox kümmert sich um die horizontale und vertikale Platzierung von Elementen, ohne auf die \ac{CSS}-Eigenschaft ?float? zurückgreifen zu müssen, die gerade bei tief verschachtelten Elementen Probleme verursacht.
%		
%		\item Das Paket `elm-lang/window` stellt eine Funktion `resize` zur Verfügung, die bei jeder Veränderung der Fensterdimensionen über eine sogenannte `subscription` in Elm einen Aufruf der `update` Funktion auslöst, an jene die neuen Fensterdimensionen (X, Y) weitergereicht werden.
%	\end{enumerate}
%
%\item Elm-Compiler
%	\begin{enumerate}[label*=\arabic*.]
%		\item Kompiliert abhängig von der Tiefe der Elemente
%		\begin{enumerate}[label*=\arabic*.]
%			\item Entwickler muss lesbaren Code erzeugen, da Elm sensitiv auf Tabs reagiert (vs\ac{HTML}: $<div><span></span></div>$ wo unendliches verschachteln auch in einer Zeile möglich ist)
%		\end{enumerate}
%	\end{enumerate}
%
%\item TODO:
%	\begin{enumerate}[label*=\arabic*.]
%		\item Fehlende Beispiele importieren
%		\item Umschreiben der Beispiele
%	\end{enumerate}
%\end{enumerate}


%
%\subsection{Hypothesen und Vermutungen}
%\label{sec:Hypothesen und Vermutungen}
%Sämtliche Hypothesen wurden in der Tabelle~\ref{tab:Hypothesentabelle} zusammengefasst. Dabei beziehen sich die einzelnen Vermutungen jeweils auf eines der zuvor erläuterten Kriterien in den Kapiteln \nameref{sec:Bewertungskriterien} (\ref{sec:Bewertungskriterien}) und \nameref{sec:ansprueche-webapp} (\ref{sec:ansprueche-webapp}). Die Nummerierungen der Hypothesentabelle~\ref{tab:Hypothesentabelle} sind gleich der Auswertungstabelle~\ref{tab:Auswertungstabelle}, so dass ein Vergleich möglich ist.
%\begin{table}[p]
%\begin{tabular}{ | l | p{7.6cm} | }
%	\hline
%	\textbf{Kriterium} &\textbf{Hypothese}\\
%	\hline
%	1. Entwicklungsgeschwindigkeit & 1.1 Elm hat leicht erlernbare Grundkonzepte, die adaptiert und erweiterbar sind, um Produktivität für die Entwickler zu gewährleisten\\
%	\hline
%	2. Wartbarkeit & 2.1 Elm Code kann mindestens kommentiert werden, wenn nicht sogar eine Funktion zur automatischen Generierung von wichtigen Informationen existiert\\
%	\hline
%	3. Zuverlässigkeit & 3.1 Die Erweiterungen des Editors, oder der Compiler selbst, warnen spätestens bei der Kompilierung, wenn nicht bereits während der Entwicklung vor syntaktischen Fehlern\\
%	& 3.2  Gibt es keine Fehlermeldungen, wird die Applikation ohne Laufzeitfehler funktionieren\\
%	& 3.3  Fehlermeldungen werden sehr spezifisch auf das eigentliche Problem hinweisen\\
%	\hline
%	4. Portabilität &  4.1 Die \ac{SPA} wird auf allen gängigen Browsern fehlerfrei dargestellt\\
%	\hline
%	5. Effizienz & 5.1 Der Kompiliervorgang wird nur wenige Sekunden dauern, jedoch mehr Zeit in Anspruch nehmen\\
%	&  5.2 Die erzeugte Elm-Applikation ist deutlich schneller während der Laufzeit\\
%	\hline
%	6. Wiederverwendbarkeit & 6.1 Codeteilen lassen sich problemlos auslagern und wiederverwenden\\
%	\hline
%	7. Modularität & 7.1 Ausgelagerte Codeteile sind isoliert voneinander und als einzelnes Modul nutzbar\\
%	& 7.2 Module können Funktionen nach außen verbergen\\
%	\hline
%	8. Lesbarkeit &  8.1 Die geforderte Formatierung des Elm-Codes macht diesen lesbarer und spart Zeit\\	
%	\hline
%	9. Dateigröße &  9.1 Die Dateigröße der Elm-Applikation wird kleiner als bei vergleichbaren Frameworks ausfallen\\
%	\hline
%	10. Interoperabilität &  10.1 Bestehende \ac{JS}-Skripte können mit der Elm-Applikation interagieren oder funktionieren bereits einwandfrei\\
%	& 10.2 Bestehender \ac{CSS}-Code kann nativ in Elm eingebunden werden\\
%	\hline
%	11. Asynchrones Laden &  11.1 Elm erlaubt asynchrone Requests ohne Seiteneffekte zu erzeugen\\
%	\hline
%\end{tabular}
%\caption{Aufstellung der Hypothesen}\label{tab:Hypothesentabelle}
%\end{table}
%
%
%\subsubsection{Grundgerüst der Applikation}
%\label{sec:Grundaufbau}
%
%\textbf{Vollautomatisch ? Elm-reactor}\\
%Mit Hilfe des $elm-reactor$ kann der gesamte Prozess der Kompilierung und Konfiguration eines Webservers automatisiert werden. Dafür muss lediglich der Ordner in dem die Elm-Applikation abgelegt wurde geöffnet und der $elm-reactor$ gestartet werden. Die geschriebene Applikation kann daraufhin lokal mit jedem Browser über die URL $http://localhost:8000/$ geöffnet werden, ohne die Notwendigkeit eines zusätzlichen Webservers. Die Abbildung~\ref{fig:elm-reactor}) zeigt den laufenden Webserver.
%Eine weitere Möglichkeit ist, den Code automatisch zu kompilieren und zusätzlich eine $elm.html$ Datei zu erzeugen. Diese Datei wird mit dem gesamten kompilierten Elm-Code bestückt und ausgeführt, sobald die Datei im Browser geöffnet wird. Für den Entwickler bedeutet dies, dass nur noch die erzeugten Dateien weitergegeben werden müssen.
%\begin{figure}[hb]
%\centering
%\includegraphics[scale=0.4]{img/elm-make_include_in_index.png}
%\caption{Grundgerüst eines\ac{HTML}-Dokumentes, um die Elm Applikation zu laden}\label{fig:html-boilerplate}
%\end{figure}
%
%\begin{figure}[htb]
%\centering
%\includegraphics[scale=0.4]{img/elm-reactor.png}
%\caption{Der gestartete Elm-Webserver}\label{fig:elm-reactor}
%\end{figure}
%
%\noindent\textbf{Manueller Grundaufbau}\\
%Überlässt man dem Compiler das Einbinden der erzeugten \ac{JS}-Datei, so ist die gesamte Elm-Applikation im Vordergrund. Das ist nicht immer wünschenswert oder gar praktikabel. Einerseits, da externe Quellen für \ac{CSS} und \ac{JS} über natives Elm nicht reibungslos geladen werden können, andererseits weil nicht immer der gesamte darzustellende \ac{HTML}-Code nur in Elm geschrieben wurde. Dementsprechend gibt es auch die Möglichkeit, eine \ac{HTML}-Datei als Gerüst zu erzeugen, in die gezielt der \ac{JS}-Code der Elm-Applikation injiziert wird. Das Gerüst ist vollständig wie eine klassische \ac{HTML}-Datei aufgebaut. Abbildung~\ref{fig:html-boilerplate} zeigt das Grundgerüst des \ac{HTML}-Dokumentes. Codezeile $4$ bindet die kompilierte Elm-Datei. Der \ac{DOM}-Knoten in welchen die Applikation injiziert wird, ist in Zeile $8$ definiert. Das injizieren der Applikation geschieht in den Zeilen $13$ bis $14$ und erhält als Parameter den zuvor erwähnten \ac{DOM}-Knoten. Um die Elm-Applikation einfügen zu können, muss die Elm-Datei vorher in der Kommandozeile kompiliert werden mit dem Kommando $elm-make\,Datei.elm\,--output=elm.js$.
%Bei dieser Art der Initialisierung kann nun noch zwischen drei weiteren Darstellungen unterschieden werden:
%
%\begin{enumerate}
%\item$fullscreen$: Der erzeugte Code der Applikation wird in den Body-Tag einer\ac{HTML}-Datei geladen und überschreibt den sonstigen\ac{HTML}-Code.
%
%\item$embed$: Der erzeugte Code der Applikation wird in den übergebenen DOM-Knoten geladen.
%
%\item$worker$: Initialisiert die Applikation ohne grafische Benutzeroberfläche.
%\end{enumerate}
%Der Vorteil bei Version 2, so wie es auch in der Abbildung~\ref{fig:html-boilerplate} realisiert wurde, ist, dass auch nur kleine Teile der gesamten Applikation in Elm implementiert werden können. Überlegt man ein bestehendes, möglicherweise komplexes Projekt zu portieren, genügt es kleinere Teile Stück für Stück zu portieren. Es muss nicht befürchtet werden, große Teile der bestehenden Applikation während der Portierung nutzlos zu machen. Ein weiterer Vorteil ist, dass externes\ac{CSS} und\ac{JS} in dem \ac{HTML}-Dokument über die \ac{HTML}-eigenen $<script>$-Tags geladen werden kann.
%Zusätzlich zum Grundgerüst der $elm.html$ muss nun noch das Grundgerüst der eigentlichen Elm-App erstellt werden. Wie im Kapitel \nameref{sec:grundlagen} beschrieben, ist Elm nach einem \ac{MVU}-Konzept aufgebaut. Entsprechend sind das die unbedingt notwendigen Funktionen, die es zu realisieren gilt. Das standardmäßig mitgelieferte Paket $elm-lang/html$ liefert die sogenannten $Html.App$-Funktionen. Diese kümmern sich um die Bereitstellung und Auslieferung der Applikation, so dass sich Entwickler ganz auf die eigentliche Programmierung konzentrieren können. Dabei variieren stets die Übergabeparameter, wodurch die Applikation leicht erweitert und komplexer werden kann, ohne Neulinge direkt abzuschrecken. So verlangt die Funktion $Html.App.beginnerProgram$ nur die bekannten Funktionen $model$, $view$ und $update$. Hierbei können jedoch keine asynchronen Funktionen wie \ac{HTTP}-Requests genutzt werden.
%Dafür gibt es die erweiterte Funktion $Html.App.program$, die als vierten Übergabeparameter sogenannte $subscriptions$ erwartet. $Subscriptions$ werden für die Kommunikation zwischen Elm und \ac{JS}, sowie Verbindungen über Websockets genutzt.
%Die dritte und letzte Möglichkeit ist die Funktion $Html.App.programWithFlags$. Hierbei wird die Übergabe eines initialen $Models$ an die Elm-Applikation ermöglicht, um den Zustand der Applikation dynamisch setzen zu können.
%\begin{figure}[ht]
%\centering\includegraphics[scale=0.6]{img/programWithFlags_pass_data.png}
%\caption{Eine beispielhafte Initialisierung der Elm-Applikation mit übergebenen Werten}\label{fig:programWithFlags2}
%\end{figure}
%Abbildung~\ref{fig:programWithFlags2} zeigt das Grundgerüst einer Elm-Applikation mit der Implementierung der Funktion $Html.App.programWithFlags$. Die $main$ Funktion erstellt dabei die eigentliche Applikation, während die Funktionen $model$, $view$ und $update$ jeweils den Zustand und die gewünschte Darstellung der Applikation beschreiben, sowie vorgeben, wie mit der Interaktion durch den Benutzer umgegangen wird. Die Funktion $subscription$ gibt in diesem Stand noch keinerlei Daten weiter und stellt eine Dummy-Funktion dar. $initialModel$ erzeugt beim Aufruf ein Model mit initialen Werten, die dem Modeltypen ($type\,alias\,Model$) entsprechen müssen. Durch das Grundgerüst der $elm.html$ und $Main.elm$-Datei kann die Applikation nun schrittweise erweitert und Funktionen hinzugefügt werden. Zuletzt wird der erzeugte Code modularisiert.


%\subsubsection{Konstruktion und Überführung des Views}
%\label{sec:Konstruktion des Views}
%Damit \ac{HTML}-Elemente erzeugt werden können, werden die gleichnamigen Funktionen aus der Bibliothek $elm-lang/html$ genutzt. Im Zuge dessen wird die Bibliothek installiert und in die $*.elm$-Datei importiert. Mit Hilfe des Keywords $exposing$ wird eine Liste der Funktionen erzeugt, die in den aktuellen Namensraum der Applikation geladen werden sollen. Diese Liste wird mit den verwendeten Funktionsnamen zur Erstellung der \ac{HTML}-Elemente gefüllt, so dass die \ac{HTML}-Elemente ohne die Definition des ursprünglichen Namensraum $Html$ genutzt werden können.
%\begin{figure}[htb]
%\centering
%\includegraphics[scale=0.3]{img/div_elm_to_html.png}
%\caption{Resultat des Elm-Codes in \ac{HTML}}\label{fig:elm-to-html}
%\end{figure}

%Wie bereits erwähnt, hat erzeugt jede Funktion das gleichnamige \ac{HTML}-Element als äquivalent. Ein $div$-Element wird dementsprechend mit dem Aufruf der Funktion $div\,[\,][\,]$  erzeugt. Es ist erkannbar, dass die Funktion zwei Listen als Übergabeparameter erwartet. Die erste Liste enthält dabei optional sämtliche Attribute, die das \ac{HTML}-Element besitzen soll. Dazu gehören beispielsweise $class$ oder $href$. Die zweite Liste kann optional weitere \ac{HTML}-Elemente enthalten, um geschachtelte Konstrukte zu erzeugen. Die Signatur für die $div$-Funktion kann in Abbildung~\ref{fig:elm-to-html} betrachtet werden. Die Abbildung zeigt ferner, die Repräsentation von Elm-Code gegenüber dem daraus resultierenden \ac{HTML}-Code. Auch ist beispielhaft die Zuweisung einer Klasse ($class$) zu sehen. Auffällig sind die fehlenden $Tag$s des \ac{HTML}-Codes. Diese werden offenbar erst während der Kompilierung erzeugt. In Elm ist lediglich das Einrücken und schachteln der Funktionen von Bedeutung, um das entsprechende \ac{HTML}-Konstrukt zu erzeugen.
%\begin{figure}[htb]
%\centering
%\includegraphics[scale=0.3]{img/elm-html-sections.png}
%\caption{Deklaration einer Sektion des Views in Elm}\label{fig:elm-view-section}
%\end{figure}

%Mit Hilfe des Tools $html-to-elm$ kann fertiger \ac{HTML}-Code automatisch in Elm-Code überführt werden. Das Tool wird für jede Sektion angewandt, um Zeit zu sparen und gleichzeitig die Funktionalität des Tools zu überprüfen. Für jede Sektion wird eine gleichnamige Funktion angelegt, die dem Muster in Abbildung~\ref{fig:elm-view-section} folgt. Die $id$ eines \ac{HTML}-Elementes könnte entsprechend stets für den Funktionsnamen $nameDerSektion$ genutzt werden, da dieses Attribut ohnehin einzigartig in einem gesamten \ac{HTML}-Dokument vorkommt und eine klare Namensgebung liefert.


%Das erste sichtbare Modul der fertigen SPA ist die Navigationsleiste. Sie soll dem Nutzer die Möglichkeit bieten schnell und einfach einen Überblick über die vorhandenen Themen auf der Webseite zu erhalten und direkt mit einem Klick auf den Reiter zu einem Thema zu springen. Damit die Navigation während des gesamten Besuches möglich ist, soll die Navigationsleiste `fixed` sein, also am oberen Bildschirmrand fest verankert bleiben und mit scrollen.
%Jedes Modul der dargestellten Seite besteht aus\ac{HTML}-Code. Folglich müssen\ac{HTML}-Tags mit Elm generiert werden. Seit dem neuesten Release von Elm (Version 0.17) wurden einige Pakete die sich für die Webentwicklung nutzen lassen zusammengeführt in das Paket `elm-lang/html`. Es erlaubt die Erzeugung von\ac{HTML} und\ac{CSS} mit nativem Elm-Code. In Elm können\ac{HTML}-Tags mit bereitgestellten Funktionen aus diesem Paket erzeugt werden. Ein\ac{HTML} `div`-Tag wird mit der gleichnamigen Funktion `div` erzeugt. Die Funktion erwartet zusätzlich zwei Argumente. Einerseits eine Liste von\ac{HTML}-Attributen wie `class`, `id` oder `href`, andererseits eine Liste von weiteren\ac{HTML}-Tags, insofern Code geschachtelt wird. Die Signatur für diese Funktion lautet wie folgt:
%`div (List Html.Attribute msg) (List Html.Html msg)`
%Entsprechend dieser Signatur wird in Abbildung XY gezeigt, wie die `div`-Funktion in Elm nach der Kompilierung in\ac{HTML} dargestellt wird.
%Nicht nur die Erstellung eines\ac{HTML}-Tags, sondern auch die Zuweisung von Attributen ist in Elm eine Funktion. So sieht man in Abbildung XY ebenso, wie eine Klasse (`class`) und ID einem Element hinzugefügt wird. Da in Elm sämtliche Funktionen ?pure functions?, also reine Funktionen sind, hat der Entwickler die Sicherheit, dass das Resultat der Funktion immer gleich bleibt.
%Des Weiteren ist es möglich die\ac{HTML}-Elemente nativ in Elm mit\ac{CSS}-Styling zu versehen. Dafür wird die gleichnamige Funktion `style` aus dem Paket genutzt. Auch diese Funktion erwartet eine Liste von Argumenten, jeweils mit einem Schlüssel (hier:\ac{CSS}-Eigenschaft) und dem dazugehörigen Wert. Zur Zeit ist es nicht problemlos möchlich nativ in Elm eine externe\ac{CSS}-Datei zu integrieren. Corey Trampe (https://gist.github.com/coreytrampe/a120fac4959db7852c0f) hat eine Möglichkeit gefunden, jedoch wird bei dieser Lösung die Seite zunächst ohne jegliches Styling dargestellt, während ein asynchroner Request die externe\ac{CSS}-Datei lädt. Sobald dieser Vorgang abgeschlossen ist, wird das heruntergeladene Styling angewandt. Der zeitliche Abstand zwischen initialem Laden und der Anwendung des Styles hat ein sichtbares ?flackern? zur Folge, wodurch eine Nutzung in einem fertigen System entfällt. Alternativ werden alle zu ladenden\ac{CSS}-Dateien im\ac{HTML}-Grundgerüst über den\ac{HTML}-Tag `link` eingebunden.


%\subsubsection{Überführung des Views}
%\label{sec:Überführung des Views}
%Für die Darstellung einer SPA wird ein fertiges und kostenloses Theme von `startbootstrap.com` verwendet. Im Zuge dessen werden alle verfügbaren Dateien heruntergeladen und die zuvor erstellten Dateien `elm.html` und `Main.elm` in denselben Ordner verschoben.
%Das Grundgerüst der `elm.html` muss nun in die `index.html` überführt werden, so dass die Elm-Applikation weiterhin in den vorhandenen \ac{HTML}-Code injiziert wird.
%Zunächst einmal muss der \ac{HTML}-Code des Themes in ausführbaren Elm-Code umgeschrieben werden, damit Elm Zugriff auf den kompletten `view` bekommt. Nur so kann Elm die Interaktion des Benutzers mit den\ac{HTML}-Elementen abfangen und entsprechend darauf reagieren. Um nicht den kompletten\ac{HTML}-Code der `index.html` per Hand in Elm-Code überführen zu müssen, wird das Tool `html-to-elm` genutzt (http://mbylstra.github.io/html-to-elm/). Dieses Online-Tool erlaubt es\ac{HTML}5-konformen Code in lauffähigen Elm-Code zu überführen. Der erzeugte Elm-Code wird dann in der `Main.elm`-Datei von der `view`-Funktion zurückgegeben., muss also entsprechend dort eingefügt werden.
%Um Modularität zu gewährleisten, wird jede Sektion der SPA, wie zum Beispiel die Navigation, die Team-Sektion oder der Footer im ersten Schritt in eine eigene Funktion ausgelagert. Jede dieser Funktionen wird dann in der `view`-Funktion aufgerufen und ergibt am Ende die gesamte Webseite. Auf diese Weise können die einzelnen Teile der SPA unabhängig voneinander modifiziert und auf Korrektheit überprüft werden. Im nächsten Schritt wird der gesamte View-Code modularisiert.



%\subsubsection{Modularisierung}
%\label{sec:Modularisierung}
%Damit ein Entwickler den Überblick über den vorhandenen Quellcode behält ist es sinnvoll einzelne Teile der Applikation in mehrere Dateien und Ordner zu verschieben. Eine solche Strukturierung hilft dabei die womöglich fehlerbehafteten Teile der Applikation zu finden und beispielsweise die Programmlogik noch deutlicher von der Applikationsdarstellung zu trennen. Dabei werden die einzelnen Funktionen des Views, also die für die Darstellung verantwortlichen Programmteile, ausgelagert in eigene Module. Dasselbe wird für die `Update` und `Model` relevanten Funktionen durchgeführt. Die notwendigen Funktionen eines jeden Moduls werden dann im Gegenzug vom Hauptmodul importiert und an den entsprechenden Stellen aufgerufen.\\\\
%\noindent\textbf{View}\\
%Jede bisherige Funktion aus dem View wird in den Ordner `View` verschoben und als gleichnamiges Modul benannt. Jedes Modul bekommt dabei den Namen des Ordners in dem es zu finden ist, gefolgt vom Namen des Views, dass es darstellt. Das für die Navigation verantwortliche Modul wird  entsprechend mit `module View.Navigation exposing (view)` initialisiert und gibt die Funktion `view` an jedes importierende Modul frei.
%Dieser Schritt dient lediglich der besseren Strukturierung des Quellcodes und der Vereinfachung für den Entwickler. Abbildung XY zeigt die Haupt-`view`-Funktion nachdem sämtliche Teile des `View`s modularisiert und entsprechend importiert wurden.\\\\
%\noindent\textbf{Update}\\
%Auch die Programmlogik kann modularisiert werden und wird dafür in den Unterordner $Update$ verschoben. Hierfür werden sämtliche Typdeklarationen ($Msg$), sowie die dazugehörige Funktion $update$ in das neue Modul `Update.Update` verschoben und auch die notwendigen Pakete hinzugefügt. Von außen kann auf das $Update$-Modul, nachdem es importiert wurde, mit dem Namespace $Update$ zugegriffen werden.\\\\
%\textbf{Model}\\
%Letztlich wird noch das $model$, das sämtliche Daten die den Status der Applikation beschreiben enthält, in ein eigenes Modul im Unterordner $Model$ überführt. Die Einbindung dieses Moduls funktioniert analog zur Modularisierung von $Update$ und $View$.
%Mit Hilfe dieser Modularisierung wird das angestrebte \ac{MVU}-Konzept von Elm besonders deutlich.

%\subsubsection{Asynchrones Laden}
%\label{sec:Asynchrones Laden - Analyse}
%Klickt man innerhalb der Portfolio-Sektion der Webseite auf ein Element, öffnet sich ein Modal in dem weitere Informationen dargestellt werden. Die bestehende Elm-Applikation wird nun um das Feature des asynchronen Ladens von Informationen erweitert, die anschließend in dem geöffneten Modal angezeigt werden.
%Zunächst muss das $model$ erweitert und angepasst werden, da dies die einzige Möglichkeit in einer Elm-Applikation ist, Daten beziehungweise den Status der Applikation zu speichern. Das `model` bekommt entsprechend ein weiteres Feld $async\_content$ vom Typ $String$.
%Bei einem Klick auf eines der Portfoliobeiträge soll entsprechend das Modal geöffnet und ein Titel präsentiert werden. In diesem Beispiel wird über eine externe API ein zufälliger String angefordert, vom Server generiert und dann an die Elm-Applikation zurückgegeben. Ebenso wäre es möglich einen Server für das Backend zu erstellen, auf dem eine Datenbank läuft, so dass Daten asynchron angefordert werden können. In diesem Fall ist es jedoch nicht notwendig ein zusätzliches Backend zu konfigurieren.
%Ein solcher asynchroner Request stellt im Grunde eine Verletzung des Konzeptes von Elm dar, dass es keinerlei Seiteneffekte gibt. Da nicht bekannt ist, wann der Request endet und welchen Status die Antwort besitzt (Failed, Success, ..?), ist zunächst nicht vorhersehbar, wie der Status der Applikation nach dem Request aussehen wird. Um dieses Problem zu vermeiden, ist es notwendig alle möglichen Fälle , also den Fall einer erfolgreichen, sowie fehlerhaften Übertragung, zu behandeln. Auf diese Weise ist gewährleistet, dass die Applikation sich nicht plötzlich in einem nicht definierten Zustand befindet.
%Einen asynchronen Request in Elm auszuführen bedarf mindestens zweier zusätzlicher Funktionen und der Importierung der Bibliotheken $Http$, $Json.Decode$ und $Task$. Des Weiteren muss der Klick auf das Portfolio-Element abgefangen werden. Dafür gibt es die $onClick$ Funktion aus der $Html.Events$-Bibliothek. Sie bekommt die auszuführende Funktion als Parameter, sieht also wie folgt aus: `onClick Update.GetRandomString`. Die möglichen `Types` von eingehenden Nachrichten (`Msg`/Klicks) wird erweitert um `GetRandomString`, sowie auch die `update`-Funktion um diesen Typ erweitert werden muss. Der entsprechende `update`-Fall `GetRandomString` gibt dann das `model`, sowie einen Effekt `fetchAsync` zurück. Die Definition dieses Effektes ist der Grund, weshalb hier von einem `managed Effect` die Rede ist und der Seiteneffekt kontrolliert verläuft. `fetchAsync` ist hierbei erneut eine Funktion, die eine Nachricht (`Msg`) an die `update`-Funktion mit dem Ergebnis des Requests zurückgibt . Elm führt den Request in Form eines `Task` aus und erwartet eine Funktion für den Fall einer erfolgreichen Übertragung, sowie eine Funktion für jeglichen Fehlerfall. In beiden Fällen wird die entsprechende Funktion ausgeführt und an die `update`-Funktion zurückgegeben. Hier wird, insofern notwendig, ein neues `model` mit veränderten Werten erzeugt und letztlich das Ergebnis auf dem Bildschirm des Nutzers sichtbar gemacht.\\



%\subsection{Auswertung}
%\label{sec:Auswertung}
%- Das bedeutet, dass nativer Code in Elm kürzer und weniger anfällig für Flüchtigkeitsfehler wie beispielsweise das Schließen eines Tags ist. Der Entwickler wird weniger syntaktische Fehler machen.\\
%
%
%\begin{table}[h]
%\centering
%\begin{tabular}{ | l | c | }
%	\hline
%	\textbf{Kriterium} & \textbf{Erfüllt}\\
%	\hline
%	1. Entwicklungsgeschwindigkeit & \\
%	1.1 & \checkmark\\
%	\hline
%	2. Wartbarkeit & \\
%	2.1  & \checkmark\\
%	\hline
%	3. Zuverlässigkeit & \\
%	3.1  & \checkmark\\
%	3.2  & \checkmark\\
%	3.3  & \checkmark\\
%	\hline
%	4. Portabilität & \\
%	4.1  & ausstehend\\
%	\hline
%	5. Effizienz & \\
%	5.1  & \checkmark\\
%	5.2  & ausstehend\\
%	\hline
%	6. Wiederverwendbarkeit & \\
%	6.1  & \checkmark\\
%	\hline
%	7. Modularität & \\
%	7.1  & \checkmark\\
%	7.2  & \checkmark\\
%	\hline
%	8. Lesbarkeit & \\
%	8.1  & \checkmark\\	
%	\hline
%	9. Dateigröße & \\
%	9.1  & ausstehend\\
%	\hline
%	10. Interoperabilität & \\
%	10.1  & \checkmark\\
%	10.2  & Nein/Nur bedingt\\
%	\hline
%	11. Asynchrones Laden & \\
%	11.1  & \checkmark\\
%	\hline
%\end{tabular}
%\caption{Auswertung der Versuchskriterien}
%\label{tab:Auswertungstabelle}
%\end{table}
%%TODO: Importieren der schriftlichen Auswertung der Tabelle~\ref{tab:Auswertungstabelle}
%
% 1.1. Elm hat leicht erlernbare Grundkonzepte, die adaptiert und erweiterbar sind, um Produktivität für die Entwickler zu gewährleisten.
% 
% 2.1. Elm Code kann mindestens kommentiert werden, wenn nicht sogar eine Funktion zur automatischen Generierung von Signaturen einer Funktion existiert
% --> Kommentare können mit `--` (single-line) oder `{- a comment - }` erstellt werden. Eine vollautomatische, explizite Erstellung der Signaturen besteht derzeit nicht. Der Compiler wird jedoch nach dem Kompiliervorgang einen Signaturvorschlag geben. Dieser Vorschlag ist auf einer niedrigeren Ebene, als es eine Deklaration wäre, ist jedoch ausreichend und wesentlich sinnvoller als eine Signatur komplett unberücksichtigt zu lassen. Beispiel: Abbildung XY ($compiler_sig_suggestion$ + $compiler_own_sig$)
% ```
% type alias Model = { counter: Int }
% increaseModel: Model -> Model
% increaseModel model =
%     {model | counter = model.counter + 1}
% 
% vs. Kompiliervorschlag
% type alias Model = { counter: Int }
% increaseModel: { a | counter : number } -> { a | counter : number }
% increaseModel model =
%     {model | counter = model.counter + 1}
% ```
% 
% 3.1. Die Erweiterungen des Editors oder der Compiler warnt spätestens bei der Kompilierung, wenn nicht bereits während der Entwicklung vor syntaktischen Fehlern
% --> Syntaktische Fehler werden vom Compiler erkannt und ein Fehler angezeigt. Der Fehler wird unterstützt durch einen Hinweis auf die mögliche Fehlerquelle (Abbildung XY ? $Compiler_syntax_error$). Die Fehlermeldung wird erst nach der Kompilierung eingeblendet.
% ```
% div [ id "elm-view" ]
%         [ Navigation.view model
%             Header.view
%         , Services.view]
% ```
% 
% 3.2. Gibt es keine Fehlermeldungen, wird die Applikation ohne Laufzeitfehler funktionieren
% --> Aufgrund der Garantien, dass es keine Seiteneffekte gibt und alle Variablen unveränderlich sind, ist die Korrektheit syntaktische und semantische Korrektheit des Codes gewährleistet. Lediglich die logische Implementierung eines Algorithmus kann noch Fehler aufweisen, dies kann jedoch nicht von einem Compiler überprüft werden.
% 3.3. Fehlermeldungen werden sehr spezifisch auf das eigentliche Problem hinweisen
% --> Wie in Abbildung iii.i zu sehen ist, gibt der Compiler nicht nur an, in welcher Zeile ein Fehler gefunden wurde, sondern liefert zusätzlich noch einen Hinweis, worin eine wahrscheinliche Fehlerquelle liegt. In diesem Beispiel weißt der Compiler auf das fehlende Komma als Fehlerquelle hin.
% 
% 4.1  1. Die SPA wird auf allen gängigen Browsern fehlerfrei dargestellt
% --> AUSSTEHEND
% 
% 5.1. Der Kompiliervorgang wird nur wenige Sekunden dauern, jedoch mehr Zeit in Anspruch nehmen, als die herkömmliche Entwicklung mit reinem\ac{HTML},\ac{CSS} und\ac{JS}
% --> Bei der herkömmlichen Entwicklung ist kein expliziter Kompiliervorgang notwendig, stattdessen übernimmt der Browser die Darstellung des übergebenen\ac{HTML},\ac{CSS} und\ac{JS} Quellcodes. Der Kompiliervorgang der Elm-Applikation dauert wie in Abbildung XY  zu sehen ist im Durchschnitt XY Sekunden. Es wurde 10x gemessen, der höchste und niedrigste Wert gestrichen und dann das arithmetische Mittel der verbleibenden 8 Messungen ermittelt.
% 
% 5.2  2. Die erzeugte Elm-Applikation ist deutlich schneller während der Laufzeit
% --> AUSSTEHEND (Abbildung - Performance - Evtl. neu?)
% 
% 6. 1. Codeteilen lassen sich problemlos auslagern und wiederverwenden
% --> Der komplette View wurde von einer großen Darstellung in mehrere Funktionen unterteilt und letztlich in ein eigenes Modul überführt. Analog dazu wurden auch das Model, sowie die Update-Funktion ausgelagert. Das einmalig definierte `Model` kann in sämtlichen Modulen wiederverwendet werden, auch die einzelnen Funktionen eines jeden Moduls finden erneut Verwendung, insofern gewünscht.
% 
% 7.1. Ausgelagerte Codeteile sind isoliert voneinander und als einzelnes Modul nutzbar
% --> Diese Eigenschaft ist gegeben.
% 7.2. Module können Funktionen nach außen verbergen
% --> Jedes Modul kann mit dem Stichwort `expose` einzelne Funktionen nach außen hin zugänglich machen. Das importierende Modul wiederum kann einzelne Funktionen in den derzeitigen globalen `Scope` laden.
% 
% 8.1. Die automatische Formatierung des Elm-Codes macht diesen lesbarer und spart Zeit
% --> Fehler werden Dank der Formatierung schnell sichtbar.
% 
% 9.1. Die Dateigröße der Elm-Applikation wird kleiner als bei vergleichbaren Frameworks ausfallen
% --> Die kompilierte Elm-Applikation hat eine Größe von etwa 300kb. Allerdings kann diese Größe um etwa 60Prozent verringert werden, wenn der Code `minified` wird.
%
%10.1. Bestehende\ac{JS}-Skripte können mit der Elm-Applikation interagieren oder funktionieren bereits einwandfrei
%--> Die Integration vorhandener\ac{JS}-Skripte verlief problemlos. Benötigt ein externes Skript Daten von der Elm-Applikation, so kann mit Hilfe von `Ports` eine gesicherte Kommunikation in beide Richtungen stattfinden.
%
%10.2. Bestehender\ac{CSS}-Code kann nativ in Elm eingebunden werden
%--> Das Einbinden von\ac{CSS} Quellen ist derzeit nicht ohne Probleme nativ in Elm möglich. Es verursacht ein ?flackern? und ist nicht für den Gebrauch in einem fertigen System geeignet.\ac{CSS}-Klassen und `inline-styling` sind jedoch nativ in Elm implementiert und erlauben ein Styling der Elemente. Externes\ac{CSS} muss jedoch über das Grundgerüst der\ac{HTML}-Datei eingebunden werden.
%
%11.1. Elm erlaubt asynchrone Requests ohne Seiteneffekte zu erzeugen
%--> Ein asynchroner Request stellt implizit einen Seiteneffekt dar, wird in Elm allerdings als gemanagter Seiteneffekt bezeichnet. In jedem Fall ist der Nutzer gezwungen eine Funktion bei einer fehlerhaften Übertragung zu übergeben, die dann die erwartenden Typen/Werte liefert.
%
%\subsection{Fazit}
%\label{sec:Fazit}
%
%  
%1. Installation sehr einfach
%1. externe Abhängigkeiten werden automatisch installiert
%2. Installation war schnell
%3. Erklärung zur Installation war deutlich
%2. Modularität möglich
%1. Jedes View-Element als eigenes Modul
%1. Paralleles arbeiten möglich
%2. Entwickler bekommen nur die notwendigen Informationen für das Interface
%3. Tools
%1.\ac{HTML}2ELM sehr hilfreich
%1. Kleinere Fehler
%1. ' verursacht Fehler (Weiterfolgende Divs wurden vernachlässigt)
%2. required --> required '' (wants Bool, got String); novalidate same
%2. Elm-Compiler
%1. Fehler von\ac{HTML}2ELM (2. Punkt) wurden sofort erkannt
%2. Fehlende Funktionen für\ac{HTML} und\ac{CSS} Attribute wurden in den Fehlermeldungen vorgeschlagen (?Did you mean Html.Attributes.required?? für ?required true?)
%4. Erklärungen der Elm-Struktur in den Guides sehr gut